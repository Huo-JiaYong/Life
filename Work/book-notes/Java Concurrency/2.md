2. 原子性

   保证数据的原子性：对数据的修改同时只能由一个线程完成

   1. 竞态条件：基于一种可能失效的观察结果来做出判断
   2. 复合操作：多个动作同时执行  获取 - 修改 - 写入   使用 AtomicLong 来实现操作

3. 加锁机制

   如果出现多个数据相互依赖的情况，如乘数和积的关系。即使变量都是线程安全的计算过程也需要同步

   1. synchronized 又称内置锁 （为什么每个对象都有呢.. 有的对象不需要同步就不需要锁啊）
   2. 重入：锁是基于对象的 获取锁是基于线程的。如果线程获取了锁，在同步块内可以重入不用再次获取

4. 用锁来保护状态

   1. 一个类的变量尽可能使用一个锁，以免维护混淆
   2. 加锁约定：将所有可变状态都封装在对象内部

5. 活跃性和性能

   1. 尽可能的将锁的范围缩小的最小
   2. **执行较长的程序时一定不要持有锁，先释放掉**