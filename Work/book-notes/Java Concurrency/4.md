1. 构建线程安全的类

   1. 找到构成对象状态的变量
   2. 找出约束状态变量的不变条件
   3. 访问对象状态的并发管理

   当构成对象状态的变量有多个并存在相互影响的话，则要保证多个变量同时管理

   依赖状态的操作：必须要达到某种状态才能完成的操作，最好使用系统提供的依赖管理（暂时不知..）

   状态的所有权：对象的所有属性都是状态的一部分。**对象封装它拥有的状态，反之亦是**。

   容器类拥有自身的状态，而将属性的所有权分离。例如：ServletContext 自身的状态自己管理，但客户拥有 attribute 的所有权

2. 实例封闭

   封闭：封装能够将属性限定在对象内，通过方法访问

   能通过几个锁来管理几个对象，使得在锁策略上更加灵活

   1. Java 监视器模式：将所有可变状态封装起来，通过内置锁管理

      监视器模式的车辆追踪：把位置保存在监视器中，获取则拷贝（对象可能已发生变化）

3. 线程安全的委托

   当使用线程安全的类管理可变变量时，那么被管理的类就是线程安全的

   1. 独立的状态变量：多个可变变量可以各自委托个多个
   2. 当委托失效：多个状态变量有相互关系时，要由统一的锁管理，而不能直接委托（自己的锁）
   3. 发布变量：当变量没有任何不变性的约束，并且操作不存在也不允许状态改变。则可以发布
   
4. 在现有的线程安全的类增加功能

   使用系统提供的线程安全类是个很好的选择，但是并不能完全满足我们的需求；我们需要进行扩展

   1. 扩展：继承线程安全类并实现额外的**安全**的功能方法

   2. 客户端加锁：在获取到线程安全对象时，使用时必须获取此对象的锁（而不是当前使用他的对象锁）

   3. 组合：将扩展和客户端加锁结合。继承原对象（覆盖原非安全方法）的同时创建操作属性的相关安全方法。

      相当于给对象包了一层线程安全的壳

5. **将同步策略文档化**

   如果设计了线程安全的类交于客户使用，则需要在文档中说明

   1. 此类是否线程安全（@GuardedBy）
   2. 设计中采用如何的同步方式
   3. 哪些变量由锁保护？哪些锁保护哪些变量？那些操作必须原子？

   **如果类未明确说明是线程安全的，那么就认为他是不安全的**
   
   从**实现者**的角度去猜这个类是否线程安全（如果他从一开始就会被多线程访问）