1. 可见性

   程序的运行结果应该是可预见的 ——可见性

   1. 重排序：编译器 JVM CPU 都有可能对你进行的操作进行重新排序，比如先写后读

   2. 失效数据：并发下获取的数据并不是当前正确的数据（脏数据）

   3. 非原子  64 位操作：

      当线程没有同步变量的时候，你可能获取了一个错误的数据。但至少这个数据是某一时刻这个变量的数值
      但是在 非 volatile 类型的 64 位数值（long double）变量中可能出现一个完全不想关的数据，因为这个变量被拆分成两个 32 位的数值进行修改（因为以前CPU还不支持64位）。

   4. volatile 变量：标记此变量是共享的，直接更新内存数值。

      最好使用在**表示状态**的变量上（确保自身的状态的可见性），而不是用以运算的变量

2. 发布与逸出

   发布：将一个对象在当前定义的作用域外使用（抛出引用）

   逸出：当某个不应该发布的对象被发布

   1. 隐式的 this 逸出：在构造方法中将 this 对象使其他对象引用，而其他对象发布的话 this 对象也被发布出去了

      在构造方法中创建新的线程，this 对象都会被引用到新线程中

   2. 解决：不在构造方法中创建新的线程，而是使用 newInstance 构造对象
   
3. 线程封闭

   有一种避免使用同步的方式就是**不共享数据**

   1. Ad-hoc 线程封闭：维护线程封闭性的职责完全由程序负责
   2. 特殊线程封闭：使用 volatile 变量并且保证只有单个线程执行写入
   3. 栈封闭：局部变量就始终封闭在方法栈内
   4. ThreadLocal：每个线程自己的变量，在线程执行完成后回收

4. 不变性

   1. 不可变对象：在创建初始化后就不会被修改

   2. final ：表示对象被初始化了之后就不能被修改。

      当线程获取了对象之后不用担心其他线程会被修改，如果要更新则创建一个新的对象。重新赋值

5. 安全发布

   如果我们想要对象不使用同步就能保证线程安全则需要安全的发布与共享

   1. 不正确的发布：对象未被正确的初始化就能够访问
   2. 不可变对象：不可变的对线在任何情况下都是线程安全的
   3. 安全的发布：1.在静态块中初始化变量 2.使用 volatile 或者 AtomicReferance 修饰 3. 保存在 final 类型域 4.锁中
   4. 事实不可变对象：对象是可变的但是没有线程修改他 就是事实不可变对象
   5. 安全的共享：1.线程封闭 2.只读共享 3.在线程安全类中 4.使用锁保护

   
