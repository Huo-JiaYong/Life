## 1. 索引基础

### 1. B-Tree 类型

InnoDB 采用的 B+Tree

所有的值都是按照顺序存储，并且每一个叶子到根的距离相同

**注意事项：**

1. 不是从最左列查找，则不能使用索引 （多列索引就必须从最左列开始指定）

2. 不能跳过索引列

   E.g.  KEY (a,b,c) /  WHERE a='a' AND c='c'

3. 如果某个列有范围查询，则右边列不能使用索引

   范围会导致多个值，而不能确定固定值

### 2. Hash 索引

将每一行的索引列生成一个  hash code，将 code 和行指针存放在索引中

只有 Memory 引擎显式支持 Hash 索引

E.g.  `KEY USING HASH(name)`

**注意事项：**

1. hash 索引不存储值，所以不能避免读取行

2. 并不是按照索引值顺序存储，所以不能排序

3. 只能**全部索引列**的值一样才能匹配

   E.g.  A='a' B='b'  /  WHERE A='a'

4. 只能进行**等值**比较

5. 会出现 hash 碰撞，需要遍历链表中的所有行

**InnoDB 中的 hash 索引**

1. **自适应哈希索引** adaptive hash index

   InnoDB 会自动将索引命中率较高的索引，在 B+Tree 的基础上再创建 hash 索引 

2. 自定义哈希索引

   当存储内容很大的时候，可以使用存储值的 hash code 并在此上建立索引来实现快速查找

   1. url , url_crc
   2. 使用触发器或在程序采用 crc32 对 url 进行加密保存
   3. WHERE url_crc = CRC32("value") **AND** url="value"

   需要指定 AND，因为当出现 CRC 碰撞的时候 就不能确定准确值了

   若有需要可自定义 hash 函数（尽量不要使用生成值太长的 hash 函数 md5-32 sha1-40）

   **采用 FNV64() 函数可以减少碰撞概率和 hash 长度**

### 3. 空间索引

根据数据在空间维度上的索引来确定位置，如 PostgreSQL

### 4. 全文索引

全文索引不是针对某一个值或数据进行索引，而是根据全部的内容进行分割索引

其实是**搜索引擎**做的事情 E.g ElasticSearch

## 2. 索引的优点

1. 大大减少了服务器需要扫描的数据量
2. 避免排序和临时表
3. 将 随机IO 变成 顺序IO （因为数据是有序的）

## 3. 高性能索引策略

### 1. 单列索引

在索引列上使用函数和任何计算都不能够使用索引

### 2. 前缀索引和索引选择性

1. 索引选择性：可以理解为索引的检索效率，重复率越高索引越慢

   不重复的索引值 / 记录总数（*#T*）  =  1/#T    -  1 

   1/#T： 记录索引的重复率

   1：是表中的唯一索引

2. 前缀索引

   当索引列的数据较长的时候会导致索引速度变慢，那么就可以取数据的前面一部分来进行索引

   `KEY (column(num)) `

   需要注意：到底取多长的数据来做索引？

   1. 长度范围内的值重复率

      如：数据都是以 san 开头，那么就至少需要取 4 以上的长度

   2. 长度内的选择性

      `DISTINCT LEFT(column, num) / count(*)`

      表示在所有记录中的使用率

3. 后缀索引

   当需要根据结尾的数据做索引的时候（统计邮箱）

   可以将数据**反转后存储**

### 3. 多列索引

多个重复的单列索引并不是一个好的选择

虽然在新版本中会自动将多个重复的单列索引组合，但这会带来性能上的开销

所以最好是在一个索引中包含多个列

### 4. 合适的索引顺序

多列索引中需要注意列的顺序

将列重复数据较少的列放在前面，用以更快的确定索引的位置

### 5. 聚簇索引

聚合索引不是一种索引策略，而是一种**数据存储**策略（数据存储在叶子节点中）

#### 如何指定索引列

现有的所有引擎都不能手动指定索引列

InnoDB 采用**主键**作为索引列，缺失使用唯一非空的索引代替，再缺失会使用一个隐式的主键作为索引列

#### 优点

1. 将相关的数据保存在一起，能够减少 IO 次数
2. 数据读取更快，索引和数据都保存在 B-Tree 中
3. 使用覆盖索引的查询能够直接使用主键值（聚簇索引存放了主键值）

#### 缺点

1. 提高了 IO 密集型的应用性能，如果数据都在内存中则效果不明显
2. 插入速度严重依赖插入顺序（若无序的索引列则会导致插入时间过长）
3. 更新聚簇索引需要强制移动行
4. 当主键值要被插入到某个已满的页中时，会导致**页分裂**（分为两个页来存储数据，占用更多空间）
5. 二级索引包含了主键列，导致数据量过大
6. 二级索引需要两次索引查找（二级索引存储的是主键列的值，而不是数据行的指针。再根据值去找对应的数据）

#### MyISAM 和 InnoDB 的数据分布

##### MyISAM

按照数据插入的顺序存储

通过额外的 “行号”（不一定是具体的行号）来找到需要的行

二级索引：与聚簇索引的方式一致

##### InnoDB

每个叶子节点都包含了：

1. 主键值
2. 事务 ID
3. RP （事务和 MVCC 的回滚指针）
4. **剩余列**

即聚簇索引中包含了所有列的数据

二级索引：存储主键值（当主键对应行的数据修改时，不会受到影响）

#### 让 InnoDB 按主键顺序存储

##### 为什么需要按照顺序插入

1. 有效避免频繁页分裂
2. 插入更快（无需定位、移动）

使用 `AUTO_INCREMENT` 自增长主键

使用自增长效率和空间都有好的表现

##### 避免随机的聚簇索引

如：使用 uuid 列作为聚簇索引列（使插入变得完全随机）

缺点：

1. 定位在页中的位置，需要将页数据加载到内存中

2. 插入到页中会导致页分裂会大量的移动数据，一次插入需要修改三个页而不是一个页

   原始页、分裂的新页、原始页的移动

3. 页分裂会导致数据碎片

##### 顺序主键的缺点

当出现并发量较高的时候，MySQL 的锁机制可能无法承受

### 6. 覆盖索引

如果一个索引包含了查询的所有列，那么这个索引就是覆盖索引

#### 优点：

1. 读取索引比读取行数据更快
2. 索引是按照**列值顺序**存储的
3. 存储引擎只能缓存索引，而不能缓存行数据（缓存行需要操作系统实现，而系统的操作会耗费大量资源）
4. InnoDB 中的二级索引包含了主键值，如果二级索引能覆盖索引则可以避免对主键索引的二次查询

#### 成为覆盖索引

不是所有的索引都能够成为覆盖索引

只有存储了**值**的索引，才能称为覆盖索引

e.g ： hash 索引、空间索引、全文索引 都不会存储索引列的值

#### 是否使用覆盖索引

```sql
-- 分析查询 EXPLAIN  格式化输出：\G
EXPLAIN SELECT store_id,film_id FROM inventory \G;
-- 是覆盖索引
Extra: Using index
```

#### 延迟关联（deferred join）

当出现 where 条件在索引的范围内，而制定获取的列不在索引列中

则可以根据 where 条件查询出 id 再关联表，则能够使用索引

```sql
SELECT * FROM products
JOIN (
	SELECT id FROM products
  	WHERE actor="xx" AND title="xxx"
) pr ON products.id = pr.id
```

**应用场景：**在很多行数据中获取**中等**数据量的行查询

1. 查询的数据量太大：主要时间浪费在读取和发送数据上，看不到连接的效果
2. 查询的数据量太小：子查询带来的成本比直接读取行更高

**在二级索引中包含主键值。所以就算主键没在索引列中，也可以使用索引**

```sql
SELECT actor_id,last_name FROM actor WHERE last_name="xxx";
```

### 7. 使用索引扫描来做排序

1. 有两种方式可以生成有序的结果

   1. 排序操作 `filesort`，需要对值进行排序
   2. 按索引顺序扫描，只需按照顺序扫描即可

2. 如何使用索引扫描来排序

   1. 排序的字段和索引的字段顺序一致
   2. 排序的方式和索引的方式一致，ASC DESC
   3. 关联表查询时： ORDER BY 的字段全部为第一个表

3. 索引排序需要满足最左前缀要求

   当索引的第一个值为常量的时候，可以不满足最左前缀要求

   index idx_user(name,city,address)

   WHERE name="huo" ORDER BY city,address

### 8. 压缩索引

​	当存储索引值的时候会和前一个索引值进行相似性比较，相同的部分则使用前一个索引值的代替

​	perform  -> perform

​	performance -> 7,ance

### 9. 冗余和重复索引

1. 冗余索引：某个字段已经在索引中存在
2. 重复索引：完全相同的字段创建两次索引  index idx(a,b)   index idx(a,b)
3. 重复索引是完全没有必要的，而冗余索引是待考虑的
4. 冗余索引会影响到数据的所有更新操作，导致更新操作时间变长

### 11. 索引和锁

查询在读取数据的时候会锁定行（具体锁策略不同），索引能够让查询锁定更少的行

1. InnoDB 只有在对行进行访问的时候才会加锁，而索引能够减少访问行数，那么就可以减少锁定行数
2. InnoDB 在二级索引上使用**读写锁**，在主键索引上使用**排他锁**