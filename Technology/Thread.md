## 个人认识

多线程能够更加有效的利用CPU的处理速度，使程序能够够快的运行

多线程的加入也意味着程序的控制会更加的具有挑战性



## 基本概念 [面试问题][http://ifeve.com/java-multi-threading-concurrency-interview-questions-with-answers/]

1. **线程和进程**

   进程：在操作系统中代表一个软件程序，很大程度上可以代表一个软件

   线程：在软件中的一个执行序列，是进程的一部分。`是进程中执行任务的一部分`

2. **用户线程和守护线程**

   用户线程：用户创建的用以执行任务的线程，即普通线程

   守护线程：用以向用户线程提供 java 系统服务的线程，常见功能：GC。守护线程在用户线程结束后并不会直接退出，而是等到**所有**的用户线程都结束后才会结束

3. **如何创建线程**

   1. extends Thread

   2. implements Runnable

   3. implements Callable

      通过 Callable 的方式可以获取到线程的执行结果 Future 对象，通过调用 Future.get() 获取执行结果

4. **线程的生命周期**

   ![线程生命周期](http://img.blog.csdn.net/20150627094953213)

   基本流程：创建 -> 启动 -> 就绪 -> 运行 -> 结束

   阻塞流程：运行 -> 阻塞（sleep join / yield） -> 就绪

   1. sleep 不会释放对象锁
   2. join 等待调用此方法的线程先执行完成
   3. yield 放弃运行机会重新进入到就绪状态，会释放对象锁。当然在就绪状态也有可能会抢到此次运行机会

   等锁流程：运行 -> 等待（其他线程持有对象锁） -> 锁定（获取到锁）-> 就绪

5. **线程的优先级**

   优先级分为 0 - 10 个等级，数字越大优先级越高

   线程的优先级调用是根据不同的系统来决定的

   设定了优先级，在不同系统中也有可能有不同的执行顺序

6. **多线程的上下文切换**

   CPU 会根据时间片来分别给多线程执行的机会

   多线程之间的切换被称为上下文切换

   上下文切换是多线程的缺点之一，会浪费掉一部分时间

   `上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行`

7. **线程间如何通信**

   通过 wait() notify() 和 notifyAll() 来提醒其他线程

8. **为什么线程通信方法被定义在 Object 中**

   因为通信的方法表示释放或者等待对象锁，而对象锁的信息存放在对象头中

   通信是为了获取对象锁，那么这个对象锁的状态就应该通过对象方法来获取

9. **sleep() 和 yield()**

   sleep 不会释放对象锁，休眠完成后进入就绪状态

   yield 会释放对象锁，时间不可控制，直接进入就绪状态。相当于放弃在这次执行机会给同级或更高优先级线程执行，重新去争抢时间片

10. **如何确保线程安全 — 同步**

  1. 通过 synchronized 关键字来标识方法或代码块，表示区域内的对象在同一时间只能被一个线程访问

     代码块更加灵活一点..

  2. 通过 Lock 对象对区域进行加锁和解锁操作

  3. 通过使用系统提供的线程安全类，如： AtomicIntger , ConcurrentHashMap等

11. **volatile 关键字**

    volatile 修饰的变量直接读取并且线程不会缓存对象值。能保证变量的原子性

12. **ThreadLocal**

    `ThreadLocal 用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择 ThreadLocal 变量`

13. **死锁**

    当两个线程都在等待对方释放对象锁的情况被称为死锁

    解决方法：设定某一方先释放对象锁

14. **线程池**

    1. 线程的不断创建和销毁会浪费大量的资源

    2. 线程池可以解决创建和销毁浪费的资源

       线程池会创建多个线程

       当需要完成操作的时候，将需要执行的任务传递到线程池

       线程池会分配某个线程来执行，从而节省创建和销毁时间

    3. 任务的存放阻塞队列 BlockingQueue 中

       阻塞队列和普通队列的不同点：阻塞队列在空或者满的情况下获取或插入数据会进入阻塞状态

15. **并发编程模型**

    1. 并发工作者模式

       操作都是并发执行的，在访问相同支援时会出现阻塞

    2. 工作流模式 / 监听模式 / 事件驱动模式

       线程完成操作后发出提示，下一步由监听时间的人执行

       线程之间松耦合

    3. 函数式并行模式

       采用函数调用实现程序

       函数之间可以像流水线模型（AKA 反应器或者事件驱动系统）那样互相发送消息

16. **线程安全和不可变性**

    当多个线程对同一资源进行写操作的时候就会发生竞态条件

    从而导致资源的不可预测性

    创建不可变性的共享对象可以解决这一问题

    **在类创建的时候确定变量，并且不提供修改方法**。即可实现线程安全

    引用不是线程安全的：当引用一个不可变类的时候，这个类是安全的。引用类的对象并不是线程安全的

17. **竞态条件和临界区**

    竞态条件：多线程在访问同一资源时，如果对资源的访问顺序敏感，就称为竞态条件

    临界区：竞态条件发生的代码区被称为临界区

18. ​




## 面试问题

1. **如何中止一个正在运行的线程**

   1. 调用 ~~stop()~~ 方法 [ 已废弃 ]
   2. 调用 interrput() 方法，它不会使当前线程直接终止，而是标记为中断。并且使线程抛出一个中断异常，从而实现线程的停止

2. **notify() 和 notifyAll() 有什么区别？**

   notify() 只会唤醒一个线程并释放锁

   notify() 会唤醒所有在 wait 的线程，各线程各自竞争

3. **sleep() 和 wait() 有什么区别?**

   sleep() 不会释放锁，并且他是线程的一种行为

   wait() 会释放锁，并且只要能获得对象的地方都可以调用此方法

4. **什么是可重入锁（ReentrantLock）？**

   `指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响`

   自旋锁：在当前线程中不断执行循环体，只有在unlock 中修改循环条件才会中断

   用以保持当前线程占用锁，当在线程较多的时候效率很低

5. **SynchronizedMap 和 ConcurrentHashMap 有什么区别？**

   SynchronizedMap 会锁住整个 Map 对象

   ConcurrentHashMap 将 Map 分为 16 块，当需要操作的时候只需要锁住对象所在的块即可

6. **CopyOnWriteArrayList 可以用于什么应用场景？**

   在对数组进行写操作的时候，会复制一份数组用以执行写操作。原数组继续提供读操作

7. **什么叫线程安全？servlet 是线程安全吗?**

   线程安全：在多线程的访问下会获得一致的结果

   是

8. **读写锁的作用**

   多线程读取数据是可以被允许的

   只要线程执行写操作的时候，读操作应该被阻塞

   ​

   ​