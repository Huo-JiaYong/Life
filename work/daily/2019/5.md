### 5 - 5

1. 有个文件扫描失败，且之后无法正常扫描（文件在扫描中，重启服务器后。任务无法完成~）
2. 学习 netty 基础概念

### 5 - 6

1. NETTY gourp loop event 使用 ServerBootstarp 创建服务
2. CommandLineRunner 和 ApplicationRunner 执行初始化操作

### 5 - 7

1. encode & decode
2. 

### 5 - 8

1. 修改LOGO图片的存放方式和位置

2. 为什么保存图片后重启~

   应该是修改项目路径下的文件，导致重新发布。放入到 /static 解决

3. 为什么 ajax 上传失败

   获取到的 response 他妈的居然是html，估计是因为缓存 卧槽

   使用隐身模式就可以了

4. 纠结是否K_V的方式来存储相关配置，如果要用的话 就需要判定是否存在之类的

   所以不

5. 新增默认的 favicon 相关路径，两边项目不一致

6. 将修改复制到uiweb项目中

### 5 - 9

1. MD UI & JRebel安装和使用

2. 修复文件扫描中，中断扫描后重启服务器无法完成任务扫描

   关闭时：将未完成的任务直接删除（数据丢失）

   启动时：重新启动则重新开始发布扫描（可能文件被自动删除）

   ​	应该不会被删除..因为关闭的时候还在扫描中

### 5 - 10

1. 排查北京测试上传LOGO图片保存正确但是无法正确显示图片问题

   因为在复制配置的时候在路径中多加了个空格..并且保存图片的时候就相当于把这个空格加上了

2. 修复任务正在扫描时关闭服务器，重启后任务无法正确被扫描的问题

   直接将之前的任务清理掉，可以重新上传

3. 修复同时上传两个相同文件导致文件被引擎扫描多次的情况

### /

### 5 - 13

1. 参加 DNS 异常检测培训
2. EDR自身安全防护问题

### 5 - 14

1. 横向移动异常检测培训， APT检测
2. 修复同时上传两个相同文件计数异常

### 5 - 15

1. 数据库连接池 **连接数 = ((核心数 \* 2) + 有效磁盘数 )**
2. 安全 coding 培训
3. 优化 HikariCP 和 MySQL 配置信息

### 5 - 16

1. 修复 uiweb 首页需要访问通用图片（图片在运维中心）需要额外打开确认允许运维中心的http证书

   两个项目映射同一个服务器上的相同图片绝对路径

### 5 - 17

1. 

### /

### 5 - 20

1. 创建多个数据源和 jdbcTemplate
2. 安装 oracle 数据库，用 pandownload 下载，并且将两个解压包都解压~
3. 测试连接 oracle 数据库，并修改数据。查询麻烦一点~毕竟要返回对象

### 5 - 21

1. 无法通过 10.11.1.40 访问，修改 listen.rsa 配置文件中的 host 属性:0.0.0.0 即可
2. 修改表的名称和结构

### 5 - 22

1. 分段下载引擎文件

   1. 如何分段，在每个请求中带一个第几段的标记（默认每段100M）

   2. 如何结束，当返回的结果中不满100M就证明结束了（如果引擎正好100M呢，虽然现在没有）

      1. 设计结束标记，这样就需要在返回的时候设计数据结构，而不是直接返回文件信息了

         导致数据进行一次protobuf的编码..

      2. 知道最后一次获取0字节的返回，则证明当前引擎下载完了

### 5 - 23

1. 运维中心，根据主机查询DNS连接信息接口和页面

### 5 - 24

1. 创建主机的文件操作查询接口和界面

### / 

### 5 - 27

1. 修复详情界面的表格总条数未展示
2. 终端主机连接查询界面 - 筛选历史记录
3. 新增根据开始时间和结束时间进行查询（ES是用默认时区可以在 range 中设置时区）

### 5 - 28

1. 新增详情界面的刷新数据功能

2. 为啥部署上去时间参数未生效

   需要全部删除后，拉最新的包上去

3. 修复不能根据文件名查询的情况

### 5 - 29

1. 新增主机的注册表操作相关查询接口
2. 完成主机的注册表操作界面相关查询和根据参数动态修改表格结构

### 5 - 30

1. 修改根据主机获取加载相关数据的表结构和完善线程加载相关界面

2. 多参数的构造方法：

   1. 根据参数设置不同的构造方法：很难扩展到较多的参数情况，容易输入错误（两个相同类型的参数挨在一起）
   2. 无参构造：初始化过程可能不一致（单个单个的设置），不能将实例设置成不可变（即所有参数是在创建对象后设置进去的，不能在一开始初始化设置后就不可变）
   3. 使用 Builder 方式：更好扩展（可以通过继承实现），更易读，可构建不可变（调用build()才创建对象），可复用（可修改某些参数后自动修改）

3. Singleton 模式的实现

   1. ```java
      public class Elvis{
          public static final Elvis INSTANCE = new Elvis();
          private void Elvis(){ ... }
      }
      ```

      表达意思明确，但可能被通过反射的方式创建新对象

   2. ```java
      public class Elvis{
          private static final Elvis INSTANCE = new Elvis();
          public Elvis getInstance(){
              return INSTANCE;
          }
      }
      ```

      也可以被反射实例化，好处：可随时修改是否是单例的，**序列化需要提供：readResolve()**

   3. ```java
      public enum Elvis{
          INSTANCE;
          public void leaveTheBuilding(){...}
      }
      ```

      通常情况下，枚举方式实现单例是最好的方式。更简洁，不可被反射实例化，免费的序列化。

      但是需要继承自一个超类的情况就不太好，除非超类也是枚举..