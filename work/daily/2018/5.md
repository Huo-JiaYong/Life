### 5-2

1. 确定 protobuf 的请求文件和结构

2. REQ 消息的父类

   将子类的流直接转换成父类，能正确的获取父类的属性（为什么没想到，当时在干啥...）

### 5-3

### 5-4

1. PUSH 指令的处理模式和接口

2. 获取配置文件中的数据   `@Value`

3. proto 文件的编写和修改

4. 讨论扫描任务的分发方式

   只有有任务则不断发送（不包含任务信息）的消息，然后引擎请求任务

### /

### 5-7

1. 修改 proto 文件的结构
2. 根据 .proto 文件生成文件
   1. 取消 package 属性
   2. 新增 option java_outer_classname="xxxxInfo";
3. addNode 根据新结构修改类
4. 测试新增
   1. 启动新线程 pull 则直接完成了当前线程的操作
   2. NodeReport -> Head 转换不正确，Action 不能正确获取。包含多余字符

### 5-8

1. 请求发送后 action 不匹配

   ZMQ 中复杂对象转换成 Head 对象会自动添加前缀 \n\b

   手动将 byte[] 的前两位去除后转换

2. 在主线程中创建新的线程来绑定端口会出现获取消息失败

   ZMQ 必须在主线程中绑定，在子线程中绑定的话会导致获取消息错误（并且没有错误信息）

   应该是获取消息的线程不能返回到主线程

3. 注入的 ZmqService 对象为空

   1. 看好到底是哪里为空.... 服务为空，还去服务里面找
   2. 直接使用 new 对象的话，spring 就不会装载 bean 

4. 修改节点状态接口

### 5-9

1. 新增节点的公司id 

   获取第一个插入的公司id （实际上只有一个公司）

2. 发送指令到节点的接口

   所有的前端的命令都将以指令的方式发送到节点上，由节点进行操作后返回操作结果

   再由服务器修改状态

3. 在主线程中想要 pull 套接字停止获取消息的操作

   问题：当 socket.recv() 的时候，如果没有消息则会一直尝试获取

   所以主线程中的计时功能并没有得到执行

   解决：在 recv() 方法后获取时间，就可以停止（并没有什么意义...）

### 5-10

1. 确定 engine 操作放在哪个服务中
   1. NodeService：所有对 Engine 的操作都是发送到节点的。并且操作的是发送到节点与引擎关联的表，而不是 Engine 本身
   2. ~~EngineService：这是对 Engine 的操作~~ 对 Engine 的操作应该是修改引擎的信息，而不是对节点下的引擎的操作
2. ​

### 5-11

1. 节点配置引擎的流程为：

   1. 下发新增引擎命令
   2. 发送下载引擎请求（根据获取的引擎信息）
   3. 获取下载的文件

2. 使用ZMQ下载文件，用REQ-REP模式是不行的

   REP 是一次返回，就需要把文件的全部内容都读取到内存中

   1. ~~新开一个端口用以传送文件（如何确定接收到的文件内容?）~~
   2. 引擎下发是一次性的，直接将文件读到内存里一次发送就行了


### /

### 5-14

1. 直接读取文件到内存中，并通过 protobuf 编码后发送
   1. 文件读取是字节流 **byte[]**，protobuf 需要的是字符流 **ByteString**
   2. 那就需要将byte[]转换成字符流，并进行编码（转换成字符流会复制一份，本来字节流就够大了...）
   3. ~~使用 protobuf 序列化之后再传递？~~
      1. Y：文件的序列化会增加长度
      2. N：不使用 protobuf 如何确定消息的格式
2. **protobuf 序列化的长度太大**

### 5-15

1. ~~问题的关键在于 protobuf 在序列化的时候，将文件的大小翻倍了~~

   是在将 byte[] -> String 的时候翻倍了

2. protobuf 使用 bytes 会跳过 utf8 检查

   所以不用把文件转换成utf8字符格式，直接用ByteString传递就行了

   就不会出现文件大小翻倍的情况了...

3. **新增引擎的处理逻辑**

   1. 发送新增命令 PUSH
   2. 接收下载请求 REQ
   3. 返回引擎文件 REP

4. 获取引擎文件回复

### 5-16

1. 节点下引擎的状态修改

2. 获取引擎文件的请求处理和文件下发

3. 新增节点引擎的测试用例 

   ```sequence
   participant Server
   participant Client

   Server->Client: 发送新增引擎指令 (PUSH)
   Client->Client: 获取指令信息 (PULL)
   Client->Server: 发送下载引擎文件请求（REQ）
   Server->Client: 返回引擎文件（REP）
   Client->Client: 保存文件
   Client-->Server: SUCCESS
   ```


### 5-17

1. 所有需要调用其他部分的地方都应该通过 Service 调用，而不是 Mapper 自己调用
2. 节点引擎的任务回复消息处理（新增，状态修改）
3. 不同消息的处理方法

### 5-18

1. 新增、修改引擎的测试用例

2. 解析 head 的方式修改

   从最后一个 \n 到两个字符删除

### / 

### 5-21

1. 日志等级划分

### 5-22

1. AOP 日志管理
2. 转正工作总结
3. logging.level.root: error

### 5-23

1. 测试使用注解做为切点
2. 修改 Log 的数据表结构和 AOP 数据组装
3. 测试 AOP @After @AfterThrowing

### 5-24

1. ~~ZMQ ProtoBuf 在前端的使用~~

   1. ZMQ 传递文件的情况如何解决？ 

      需要前端获取到文件转换字节流然后传送

   2. protobuf 在前端的使用问题

      原生支持的 JSON 更方便

      protobuf 需要将数据转换成二进制在转换成对象，在前端更加麻烦

2. 新增扫描任务

   记录扫描文件的源文件名