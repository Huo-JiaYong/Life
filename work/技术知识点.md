### 多线程

#### 线程状态

1. start \ run \ sleep（计时等待） \ wait （等待）\ yield（让行） \ join（等待其他执行）
2. sleep 和 wait 的区别
   1. wait 属于 object 类中的方法，需要获得对象的锁
   2. wait 需要在同步代码块中
   3. wait 会释放锁，sleep 不会
   4. sleep 延迟状态自动结束，wait 需要被唤醒

#### 线程池

1. Fixed 、Single、Scheduled、Cache
2. 任务的顺序：coreSize > queueSize > maxSize 
3. 拒绝策略：直接拒绝、调用者运行、丢弃最老、直接丢弃
4. Fixed、Single 默认队列大小为 Integer.MAX ，可能 OOM
5. Scheduled、Cache 默认线程池大小为 Integer.MAX，可能 OOM
6. 线程池推荐大小：CPU密集 n+1 、IO密集 2n

#### 线程安全

读多写少的情况下，推荐使用乐观锁（尽量减少加锁的行为）：Version \ Compara And Swap

##### synchronized

synchronized 修饰代码块（monitorenter monitorexit）和方法 （flags）

1. 实现：对象头中 Mark word 记录对象hash、锁信息（持有线程id 、锁状态等）、年龄分代、GC标志等
2. 锁状态：无锁、偏向锁（当前线程优先）、轻量锁（CAS避免切换线程）、重量锁（阻塞其他线程）

##### Lock

1. ReentrantLock 官方提供的互斥锁，锁实现采用自旋，不断循环调用CAS操作来避免线程进入内核阻塞状态
2. 公平锁的实现方式：所有的线程请求锁时，都将放入一个队列中。按照 FIFO 的方式获取锁
3. 公平锁因为要放入队列然后在获取，当只有一个线程时，也会执行此操作。涉及到切换，所以效率低

##### synchronized & ReentrantLock 

1. sync 是 JAVA 关键字，R 只是提供的一个 API
2. 原理：锁状态的升级，R 使用CAS自旋机制实现操作原子性 和 volatile 实现可见性
3. 使用：sync 自动释放，R 需要手动释放锁
4. sync 不可中断，R 可以使用超时方法、调用 interrupt 方法
5. sync 不可设置公平锁，R 可以设置

##### AQS 思想

抽象式的队列同步器，是一个用来构建锁和同步器的框架。

同步器：用以实现原子化操作的一种方案

队列：线程阻塞和唤醒时分配方案

常见实现：Lock 、CountDownLatch（计数）、Semaphore（信号量）

##### ThreadLocal

1. ThreadLocal 是指定的对象会被保存到 Thread.threadLocalMap 中
2. ThreadLocal 内存泄露的问题：Map 中 key 是对象的弱引用，可能被回收了。value 是强引用没有被回收

##### 锁优化

1. 如何优化锁的使用：
   1. 减少锁应用的范围
   2. 减小锁力度（拆分多个锁）
   3. 锁粗化（避免多次操作）例：在循环外加锁
   4. 根据场景选择不同的锁
   5. 使用 CAS 乐观锁 + volatile

#### 内存模型

1. 线程安全主要就是保护内存数据（资源）的一致性

   原子性 - sync

   可见性 - volatile\final

   有序性

2. volatile 使用 lock 指令实现内存可见性 + 有序性，建立内存屏障并禁止指令重排
   1. 强制写入到主内存
   2. 写入会导致其他 core 缓存失效
   3. 禁止之后的指令重排到之后 lock 之前

### Spring

#### 主要功能

1. IoC（Inverse of Controller）将对象的管理权限交给框架管理，IoC 容器实际上是 Map
2. DI（Dependancy Injection）使用容器将对象引入
3. AOP（Aspect-Oriented Programming）面向切面编程，降低系统模块耦合度

#### Bean

##### 生命周期

singleton：和 IoC 容器一个周期

prototype：使用时创建，使用过程中一直存活，不用被 GC 回收

##### 加载流程

1. 实例化（new Object）
2. 设置属性（设置各个属性值，注入依赖的 bean 等）
3. Aware（BeanNameAware、BeanFactoryAware、ApplicationContextAware）
4. BeanPostProcess 的 postProcessBeforeInitialization() 
5. 调用指定 init-method 方法
6. postProcessAfterInitialization()
7. 创建完成，可以使用

##### 清理 Bean

1. 实现的 DisposableBean 接口
2. 调用指定 destory-method 方法

##### 循环依赖

Spring 采用三级缓存的方式来解决循环依赖的问题

一级缓存（singletonObjects）：创建好的所有 singleton Bean

二级缓存（earlySingletonObjects）：在调用 getSingleton() 从三级缓存中移出的对象

三级缓存（singletonFactories）：刚实例化的 Bean

![循环依赖的返回](img/spring三级缓存.png)

