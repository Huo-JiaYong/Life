#### 多线程

##### 线程状态

1. start \ run \ sleep（计时等待） \ wait （等待）\ yield（让行） \ join（等待其他执行）
2. sleep 和 wait 的区别
   1. wait 属于 object 类中的方法，需要获得对象的锁
   2. wait 需要在同步代码块中
   3. wait 会释放锁，sleep 不会
   4. sleep 延迟状态自动结束，wait 需要被唤醒

##### 线程池

1. Fixed 、Single、Scheduled、Cache
2. 任务的顺序：coreSize > queueSize > maxSize 
3. 拒绝策略：直接拒绝、调用者运行、丢弃最老、直接丢弃
4. Fixed、Single 默认队列大小为 Integer.MAX ，可能 OOM
5. Scheduled、Cache 默认线程池大小为 Integer.MAX，可能 OOM
6. 线程池推荐大小：CPU密集 n+1 、IO密集 2n

##### 线程安全

1. 读多写少的情况下，推荐使用乐观锁（尽量减少加锁的行为）：Version \ Compara And Swap
2. synchronized 修饰代码块（monitorenter monitorexit）和方法 （flags）
   1. 实现：对象头中 Mark word 记录对象hash、锁信息（持有线程id 、锁状态等）、年龄分代、GC标志等
   2. 锁状态：无锁、偏向锁（当前线程优先）、轻量锁（CAS避免切换线程）、重量锁（阻塞其他线程）
3. ReentrantLock 官方提供的互斥锁，锁实现采用自旋，不断循环调用CAS操作来避免线程进入内核阻塞状态
4. synchronized 和 ReentrantLock 的区别
   1. sync 是 JAVA 关键字，R 只是提供的一个 API
   2. 原理：锁状态的升级，R 使用CAS自旋机制实现操作原子性 和 volatile 实现可见性
   3. 使用：sync 自动释放，R 需要手动释放锁
   4. sync 不可中断，R 可以使用超时方法、调用 interrupt 方法
   5. sync 不可设置公平锁，R 可以设置
5. 公平锁的实现方式：所有的线程请求锁时，都将放入一个队列中。按照 FIFO 的方式获取锁
6. 公平锁因为要放入队列然后在获取，当只有一个线程时，也会执行此操作。涉及到切换，所以效率低
7. 如何优化锁的使用：
   1. 减少锁应用的范围
   2. 减小锁力度（拆分多个锁）
   3. 锁粗化（避免多次操作）例：在循环外加锁
   4. 根据场景选择不同的锁
   5. 使用 CAS 乐观锁 + volatile
8. ThreadLocal 是指定的对象会被保存到 Thread.threadLocalMap 中
9. ThreadLocal 内存泄露的问题：Map 中 key 是对象的弱引用，可能被回收了。value 是强引用没有被回收

##### 内存模型

1. 线程安全主要就是保护内存数据（资源）的一致性，实现方式：原子性-sync、可见性-volatile\final、有序性
2. volatile 使用 lock 指令实现内存可见性 + 有序性，建立内存屏障并禁止指令重排
   1. 强制写入到主内存
   2. 写入会导致其他 core 缓存失效
   3. 禁止之后的指令重排到之后 lock 之前
3. 