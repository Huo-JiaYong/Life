## Spring Cloud 2.0 - power by Alibaba

Spring Boot：2.3.12.RELEASE 

Spring Cloud：Hoxton.SR12

Spring Cloud Alibaba：2.2.7.RELEASE

### Nacos

动态服务发现、配置、动态 DNS 等一体的软件

##### 常用配置：

1. 命名空间：用以进行服务大的分类，如进行项目分类
2. 分组：对服务进行小的分组，如 dev prod 环境区分
3. 元数据：以服务进行自定义的数据，会直接下发到服务（需要自行适配处理）
4. 保护阈值：值：0~1，当服务的可用比例超过保护阈值的情况下，整个服务不可用
5. 临时实例：ephemeral: true / false，永久实例：即使服务不可用依旧会被调用到
6. 权重：手动分配各个服务节点的使用比例

#### 注册中心

1. 直接下载 nacos-windows.zip 解压
2. 使用命令 /bin/startup.cmd -m standalone 启动 nacos 服务（普通模式需要配置数据库）
3. 使用 IP:8848 访问页面，账号：nacos nacos

#### 提供者

1. 引入 spring-cloud-starter-alibaba-nacos-discovery 包
2. 配置 spring.cloud.nacos.discovery.server-addr: 10.11.200.54:8848 和 spring.application.name 指定服务的名称
3. 使用 @EnableDiscoveryClient 注解，打开服务发现功能
4. 启动后可以在 nacos 看到指定的服务

#### 消费者

1. 前三步，同上
2. 使用 RestTemplate.getForObject("http://{服务名称}/URI", RESPONSE.class) 即可调用远程服务

#### 配置方

1. 再引入 spring-cloud-starter-alibaba-nacos-config 包
2. 新增 bootstrap.yml 配置文件（用以基础配置 spring.application.name nacos 等）
3. 新增 application.yaml 指定配置文件等级 spring.profiles.active: dev
4. 在 nacos 上新增 {name}-dev.yaml 配置文件，并填入配置
5. 直接使用 @Value("${xxx}") 即可引用配置项，并会自动更新

### Ribbon & LoadBalancer

ribbon 因为停止维护，现都优先采用 loadbalancer 组件

常用的负载均衡算法：

1. RandomRule 随机
2. RoundRobinRule 轮询
3. RetryRule 轮询重试
4. WeightedResponseTimeRule 响应时间权重
5. BestAvailableRule 最佳负载
6. ZoneAvoidanceRule 地区（默认）

#### 替换负载策略

1. 创建一个 bean 返回 IRule 的一个实现类
2. 指定服务的负载策略：微服务名.ribbon.NFLoadBalancerRuleClassName = 完整类名

### OpenFeign

用以通过直接以本地方法的方式调用微服务的接口

#### 使用

1. 引入 spring-cloud-starter-openfeign 包
2. 在启动类上新增 @EnableFeignClients 注解，打开服务
3. 创建一个接口指定对应微服务的接口，使用 @FeignClient(value = "微服务名称", path="/controller") 注解
4. 在接口中创建方法声明（要与微服务中的一致，@PathVariable 必须指定名称）

#### 服务日志打印

默认的日志信息的级别是 debug ，需要在配置文件中修改指定包 or 类的日志等级

1. 全局配置类：配置一个 bean 返回 feign.Logger.Level.（NONE / BASIC/ HEADER / FULL）
2. 局部配置：新增 @FeignClient( configuration = FeignConfig.class )
3. 配置文件：feign.client.config.微服务名称.loggerLevel

#### 兼容之前的 Feign 的注解

1. 全局配置类：配置一个 bean 返回 Contract .Default();
2. 配置文件：feign.client.config.微服务名称.contract=feign.Contract.Default

#### 超时时间配置

1. 全局配置类：配置一个 bean 返回 Request.Options(5000, 10000)，1.连接时间 2.超时时间
2. 配置文件：feign.client.config.微服务名称.connectionTime \ readTimeout

#### 自定义拦截器

如果需要在请求微服务之前做某些操作，可以通过拦截器实现

1. 实现接口：RequestInterceptor.apply ，并创建 bean 返回实例
2. 配置文件：feign.client.config.微服务名称.requestInterceptors[0] = 完整类名

### nacos-config

**维护性：**用以进行配置和程序的分离，微服务可能出现组件伸缩的情况，配置和程序绑定更新起来太麻烦

**时效性：**定时10ms对比配置中心与本地的版本（md5）是否匹配，同步效率很高

**安全性：**可以进行环境划分，比如 dev 、pro 的环境分隔等

可以严格的权限划分，比如开发人员只能访问 dev 环境等

#### 权限控制

需要在 nacos 的配置文件中将 nacos.core.auth.enable=true 打开权限控制功能

#### 默认配置

1. 在 nacos 配置中心直接新增一个名为 ${spring.application.name} 的配置（默认 .properties）
2. 在程序中使用 bootstrap.yml 配置 nacos 地址、微服务名称等**基础信息**
3. 在程序中即可读取相关配置的值

##### 配置文件类型

在使用非 .properties 的类型配置时，**需要在 Data Id 上指定使用的文件类型**。

如：order-server.yaml

##### 指定环境配置

1. ${spring.application.name}-\${profile}.{file-extension}   如：order-server-dev.yaml

2. 修改配置：spring.cloud.nacos.config.file-extension: yaml

##### Namespace & Group

最佳实践： Namespace 用以生产环境区分，Group 用以项目区分

spring.cloud.nacos.config.namespace 指定对应的命名空间

spring.cloud.nacos.config.group 指定对应的项目

##### 使用 @Value 访问

默认情况下无法感知到修改后的配置，需要在使用的 @value 访问配置的类上新增 @RefreshScope 注解

#### 配置优先级

**profile > 默认配置 > extension-configs > shared-configs（下标越大越优先）**

1. edr-dev.yaml 	         精准环境配置（环境）
2. edr.yaml                     同工程不同环境的通用配置（通用）
3. edr-618-redis.yaml   不同工程的扩展配置（大促）
4. edr-redis.yaml           不同工程的通用配置（公共组件）

#### 自定义扩展 Data Id 配置

默认的配置（以微服务名称做为 Data Id）不能满足引用公共组件（redis 等）配置的情况

```yaml
spring:
  cloud:
    nacos:
      config:
        extension-configs:
          - data-id: aliyun-redis.yaml
            group: ALIYUN_EDR
            refresh: true
      	sharded-configs:
      	  - data-id: aliyun-redis.yaml
      	    group: ALIYUN_EDR
      	    refresh: true
```

### Sentinel

是面向分布式的高可用**流量控制**组件，主要用于流量控制、熔断降级、系统负载保护等帮助用户保护服务的稳定性

![arch overview](https://sentinelguard.io/docs/zh-cn/img/sentinel-slot-chain-architecture.png)

#### 控制中心

1. 下载 sentinel-1.8.6.jar 文件到本地
2. 直接使用 java -jar sentinel-1.8.6.jar 启动 sentinel 服务
3. 使用 IP:8080 访问页面，使用 sentinel\sentinel 账号登录

#### 资源方

资源：进行流量控制的最小单元，可以是一个类、方法、一段代码等

1. 引入 spring-cloud-starter-alibaba-sentinel 包
2. 新增 spring.cloud.sentinel.transport.dashboard \ port 配置项
3. 创建一个 RESTful 接口

##### 自动扫描

支持对主流 web 框架的 url 资源自动扫描，并将其自动定义为资源。

Web Servlet、Dubbo、Spring Cloud、gRPC、Spring WebFlux 和 Reactor 等

##### 使用 SphU 定义

SphU 使用 try-catch 的方式定义资源，即：如果资源进行降级则抛出 BlockException 异常

```java

Entry entry = null;
try {
    entry = SphU.entry("资源名称");
    // TODO 一些业务处理
} catch (BlockException ex) {
    LOG.info("被降级啦");
} finally {
    if (entry != null) {
        entry.exit();
    } 
}
```

##### 使用 SphO 定义

SphO 是用 if-else 的方式定义资源，即：如果资源降级则返回 false 

```java
if (SphO.entry("资源名称")) {
    try {
        // TODO 一些业务处理
    } finally {
        // 资源必须被释放
        ShpO.exit();
    }
} else {
    LOG.info("被降级啦");
}
```

##### 使用 @ResourceSentinel 定义（推荐）

```java
@ResourceSentinel(value = "资源名称")
public String getUserName();
```

#### 流量控制

##### 控制台创建规则

1. 在控制中心左侧找到服务，后点击簇点链路，找到定义的**资源名称**
2. 点击后方的流控按钮
3. 阈值类型：QPS \ 并发线程数
4. 单机阈值：2
5. 流控模式：直接 \ 关联 \ 链路 
6. 流控效果：快速失败 \ Warm up \ 排队等待
7. 指定限流的处理方法：@ResourceSentinel(blockHandler = "getUsernameBlockHandler" ) 
8. 创建的处理方法：**1.public 2.返回类型和资源方法一致 3.参数上新增 BlockException 4.非同类指定 static**

##### 代码创建

```java
private static void initFlowRules() {
    FlowRule rule = new FlowRule();
    rule.setResource("getUsername");
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    rule.setCount(2);
    
    // 添加限流规则
    FlowRuleManager.loadRules(Collections.singleton(rule));
}
```

#### 熔断降级

熔断状态转换：

重点：熔断开启 **-- 熔断时长 -->** 探测恢复状态 **-- 请求成功 -->** 熔断关闭

![Sentinel 熔断状态转换](https://c.biancheng.net/uploads/allimg/211210/10252343H-15.png)

##### 控制台创建规则

1. 找到资源名称后的熔断按钮
2. 熔断策略：慢调用比例 \ 异常比例 \ 异常数
3. 异常数：2
4. 熔断时长：5s
5. 最小请求数：2
6. 统计时长：1000ms
7. 指定降级处理方法：@ResourceSentinel( fallback = "getUsernameFallbackHandler" )
8. 创建降级方法：**1.public 2.返回类型和资源方法一致 3.参数上新增 BlockException 4.非同类指定 static**

##### 代码创建

```java
private static void initDegradeRule() {   
    DegradeRule rule = new DegradeRule("getUsername");
    rule.setGrade(CircuitBreakerStrategy.ERROR_RATIO.getType());
    rule.setCount(0.7);
    rule.setMinRequestAmount(100);
    rule.setStatIntervalMs(30000);
    rule.setTimeWindow(10);

    DegradeRuleManager.loadRules(Collections.singleton(rule));
}
```

#### 系统保护

设置 CPU 的占用比例阈值，以保证程序稳定运行

#### 访问控制规则

通过设置黑白名单来保护资源是否可以被调用

#### 热点参数限流

对访问频次高的数据源进行调用次数的限制

### Seata

